/* ================================================================================================================= */
/*
 * DESCRIPTION:
 *   Comparison extensions.
 */
/* ================================================================================================================= */

declare global
{
    interface Map<K, V>
    {
        delete(key: K): boolean;
        get(key: K): V;
        has(key: K): V;
        set(key: K, value: V): Map<K, V>;
    }

    interface Object
    {
        hash(): number;
    }

    interface String
    {
        hash(): number;
    }
}

/* ================================================================================================================= */

const HASH_KEY: unique symbol = Symbol('tau:common:hash');
const MERSENNE_PRIME: number = 227832; // 2^32 - 1

let g_hashRngState = Math.floor(Math.random() * MERSENNE_PRIME);
 
/**
 * XOR shift random number generation.  
 *
 * __NOT_CRYPTOGRAPHICALLY_SECURE!!!!_DO_NOT_USE_FOR_ENCRYPTION!!!!!__
 *
 * Other than the initial seed value from Math.random(), this RNG will run outside of the Math.random(), thus not
 * affecting other things depending on the standard Math.random().
 * 
 * This function is used to generate a unique value per object for hashing.
 */
function xorShift(): number
{
    g_hashRngState ^= g_hashRngState << 13;
    g_hashRngState ^= g_hashRngState >> 17;
    g_hashRngState ^= g_hashRngState << 5;

    return g_hashRngState;
}

/* ================================================================================================================= */
/**
 * This function gets (or generates) a hash value for an object.
 *
 * This is the default implementation for objects that do not define hash() on their own.
 *
 * The value generated by this function is not useful outside of the running instance; subsequent runs
 * will get different hash values.
 */
function hashObject(): number
{
    let hash = this[HASH_KEY];

    if (hash == null)
    {
        hash = xorShift();
        this[HASH_KEY] = hash;
    }

    return hash;
}

/* ================================================================================================================= */
/**
 * This function gets the hash value for a string.
 *
 * The value generated by this function could change from one implementation to the next, and is not suitable for
 * use outside storage or for one run to the next.
 */
function hashString(): number
{
    let hash = this[HASH_KEY];

    if (hash == null)
    {
        hash = 0;

        for (let i = 0; i < this.length; ++i)
        {
            hash = hash << 4 + this.charCodeAt(i);
            let g = hash & 0xF0000000;

            if (g != 0)
            {
                hash ^= g >> 24;
                hash ^= g;
            }
        }

        this[HASH_KEY] = hash;
    }

    return hash;
}

/* ================================================================================================================= */

let hashDelete = Map.prototype.delete;
let hashGet = Map.prototype.get;
let hashHas = Map.prototype.has;
let hashSet = Map.prototype.set;

/* ================================================================================================================= */

function newDelete<K>(key: K): boolean
{
    if (key instanceof Number)
    {
        return hashDelete.apply(this, key);
    }
    else
    {
        let hash = key.hash();
        return hashDelete.apply(this, hash);
    }
}

/* ================================================================================================================= */

function newGet<K, V>(key: K): V
{
    if (key instanceof Number)
    {
        return hashGet.apply(this, key);
    }
    else
    {
        let hash = key.hash();
        return hashGet.apply(this, hash);
    }
}

/* ================================================================================================================= */

function newHas<K>(key: K): boolean
{
    if (key instanceof Number)
    {
        return hashHas.apply(this, key);
    }
    else
    {
        let hash = key.hash();
        return hashHas.apply(this, hash);
    }
}

/* ================================================================================================================= */

function newSet<K, V>(key: K, value: V): Map<K, V>
{
    if (key instanceof Number)
    {
        return hashSet.apply(this, [ key, value ]);
    }
    else
    {
        let hash = key.hash();
        return hashSet.apply(this, [ hash, value ]);
    }
}

/* ================================================================================================================= */

Object.prototype.hash = hashObject;

/* ================================================================================================================= */

String.prototype.hash = hashString;

/* ================================================================================================================= */

Map.prototype.delete = newDelete;
Map.prototype.get = newGet;
Map.prototype.has = newHas;
Map.prototype.set = newSet;

/* ================================================================================================================= */

export {};

/* ================================================================================================================= */
